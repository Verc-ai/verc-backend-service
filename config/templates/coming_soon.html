<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="description" content="Verc - AI-Powered Call Analysis & Compliance Platform">
  <title>Verc - Coming Soon</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'Roboto', 'Oxygen', 'Ubuntu', 'Cantarell', sans-serif;
      background: #000;
      min-height: 100vh;
      color: #ffffff;
      overflow: hidden;
      position: relative;
    }

    #liquid-ether-bg {
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      z-index: 0;
    }

    .content-wrapper {
      position: relative;
      z-index: 1;
      width: 100%;
      height: 100vh;
      pointer-events: none;
    }

    .logo {
      position: absolute;
      top: 2rem;
      left: 2rem;
      font-size: 2.5rem;
      font-weight: 700;
      letter-spacing: -1px;
      text-shadow: 0 2px 4px rgba(0, 0, 0, 0.3);
    }

    .coming-soon {
      position: absolute;
      top: 50%;
      left: 50%;
      transform: translate(-50%, -50%);
      text-align: center;
    }

    .coming-soon-word {
      font-size: 6rem;
      font-weight: 700;
      line-height: 1.1;
      letter-spacing: -3px;
      text-shadow: 0 4px 8px rgba(0, 0, 0, 0.3);
      display: block;
    }


    @media (max-width: 768px) {
      .logo {
        font-size: 2rem;
        top: 1.5rem;
        left: 1.5rem;
      }

      .coming-soon-word {
        font-size: 4rem;
      }
    }

    @media (max-width: 480px) {
      .coming-soon-word {
        font-size: 3rem;
      }
    }
  </style>
</head>
<body>
  <div id="liquid-ether-bg"></div>

  <div class="content-wrapper">
    <div class="logo">Verc</div>

    <div class="coming-soon">
      <span class="coming-soon-word">Coming</span>
      <span class="coming-soon-word">Soon</span>
    </div>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.160.0/build/three.min.js"></script>
  <script>
    // Full LiquidEther fluid simulation implementation
    (function() {
      const container = document.getElementById('liquid-ether-bg');
      if (!container) return;

      container.style.touchAction = 'none';

      const colors = ['#5227FF', '#FF9FFC', '#B19EEF'];
      const mouseForce = 40;
      const cursorSize = 70;
      const resolution = 0.5;
      const dt = 0.014;
      const iterationsPoisson = 32;
      const isBounce = false;
      const BFECC = true;
      const autoDemo = true;
      const autoSpeed = 0.5;
      const autoIntensity = 2.2;
      const isViscous = true;
      const viscous = 30;
      const iterationsViscous = 32;

      // Create palette texture from colors
      function makePaletteTexture(stops) {
        const w = stops.length;
        const data = new Uint8Array(w * 4);
        for (let i = 0; i < w; i++) {
          const c = new THREE.Color(stops[i]);
          data[i * 4 + 0] = Math.round(c.r * 255);
          data[i * 4 + 1] = Math.round(c.g * 255);
          data[i * 4 + 2] = Math.round(c.b * 255);
          data[i * 4 + 3] = 255;
        }
        const tex = new THREE.DataTexture(data, w, 1, THREE.RGBAFormat);
        tex.magFilter = THREE.LinearFilter;
        tex.minFilter = THREE.LinearFilter;
        tex.wrapS = THREE.ClampToEdgeWrapping;
        tex.wrapT = THREE.ClampToEdgeWrapping;
        tex.generateMipmaps = false;
        tex.needsUpdate = true;
        return tex;
      }

      const paletteTex = makePaletteTexture(colors);
      const bgVec4 = new THREE.Vector4(0, 0, 0, 0);

      // Shaders
      const face_vert = `
        attribute vec3 position;
        uniform vec2 px;
        uniform vec2 boundarySpace;
        varying vec2 uv;
        precision highp float;
        void main(){
          vec3 pos = position;
          vec2 scale = 1.0 - boundarySpace * 2.0;
          pos.xy = pos.xy * scale;
          uv = vec2(0.5)+(pos.xy)*0.5;
          gl_Position = vec4(pos, 1.0);
        }
      `;

      const advection_frag = `
        precision highp float;
        uniform sampler2D velocity;
        uniform float dt;
        uniform bool isBFECC;
        uniform vec2 fboSize;
        uniform vec2 px;
        varying vec2 uv;
        void main(){
          vec2 ratio = max(fboSize.x, fboSize.y) / fboSize;
          if(isBFECC == false){
            vec2 vel = texture2D(velocity, uv).xy;
            vec2 uv2 = uv - vel * dt * ratio;
            vec2 newVel = texture2D(velocity, uv2).xy;
            gl_FragColor = vec4(newVel, 0.0, 0.0);
          } else {
            vec2 spot_new = uv;
            vec2 vel_old = texture2D(velocity, uv).xy;
            vec2 spot_old = spot_new - vel_old * dt * ratio;
            vec2 vel_new1 = texture2D(velocity, spot_old).xy;
            vec2 spot_new2 = spot_old + vel_new1 * dt * ratio;
            vec2 error = spot_new2 - spot_new;
            vec2 spot_new3 = spot_new - error / 2.0;
            vec2 vel_2 = texture2D(velocity, spot_new3).xy;
            vec2 spot_old2 = spot_new3 - vel_2 * dt * ratio;
            vec2 newVel2 = texture2D(velocity, spot_old2).xy;
            gl_FragColor = vec4(newVel2, 0.0, 0.0);
          }
        }
      `;

      const mouse_vert = `
        precision highp float;
        attribute vec3 position;
        attribute vec2 uv;
        uniform vec2 center;
        uniform vec2 scale;
        uniform vec2 px;
        varying vec2 vUv;
        void main(){
          vec2 pos = position.xy * scale * 2.0 * px + center;
          vUv = uv;
          gl_Position = vec4(pos, 0.0, 1.0);
        }
      `;

      const externalForce_frag = `
        precision highp float;
        uniform vec2 force;
        uniform vec2 center;
        uniform vec2 scale;
        uniform vec2 px;
        varying vec2 vUv;
        void main(){
          vec2 circle = (vUv - 0.5) * 2.0;
          float d = 1.0 - min(length(circle), 1.0);
          d *= d;
          gl_FragColor = vec4(force * d, 0.0, 1.0);
        }
      `;

      const color_frag = `
        precision highp float;
        uniform sampler2D velocity;
        uniform sampler2D palette;
        uniform vec4 bgColor;
        varying vec2 uv;
        void main(){
          vec2 vel = texture2D(velocity, uv).xy;
          float lenv = clamp(length(vel), 0.0, 1.0);
          vec3 c = texture2D(palette, vec2(lenv, 0.5)).rgb;
          vec3 outRGB = mix(bgColor.rgb, c, lenv);
          float outA = mix(bgColor.a, 1.0, lenv);
          gl_FragColor = vec4(outRGB, outA);
        }
      `;

      const divergence_frag = `
        precision highp float;
        uniform sampler2D velocity;
        uniform float dt;
        uniform vec2 px;
        varying vec2 uv;
        void main(){
          float x0 = texture2D(velocity, uv-vec2(px.x, 0.0)).x;
          float x1 = texture2D(velocity, uv+vec2(px.x, 0.0)).x;
          float y0 = texture2D(velocity, uv-vec2(0.0, px.y)).y;
          float y1 = texture2D(velocity, uv+vec2(0.0, px.y)).y;
          float divergence = (x1 - x0 + y1 - y0) / 2.0;
          gl_FragColor = vec4(divergence / dt);
        }
      `;

      const poisson_frag = `
        precision highp float;
        uniform sampler2D pressure;
        uniform sampler2D divergence;
        uniform vec2 px;
        varying vec2 uv;
        void main(){
          float p0 = texture2D(pressure, uv + vec2(px.x * 2.0, 0.0)).r;
          float p1 = texture2D(pressure, uv - vec2(px.x * 2.0, 0.0)).r;
          float p2 = texture2D(pressure, uv + vec2(0.0, px.y * 2.0)).r;
          float p3 = texture2D(pressure, uv - vec2(0.0, px.y * 2.0)).r;
          float div = texture2D(divergence, uv).r;
          float newP = (p0 + p1 + p2 + p3) / 4.0 - div;
          gl_FragColor = vec4(newP);
        }
      `;

      const pressure_frag = `
        precision highp float;
        uniform sampler2D pressure;
        uniform sampler2D velocity;
        uniform vec2 px;
        uniform float dt;
        varying vec2 uv;
        void main(){
          float p0 = texture2D(pressure, uv + vec2(px.x, 0.0)).r;
          float p1 = texture2D(pressure, uv - vec2(px.x, 0.0)).r;
          float p2 = texture2D(pressure, uv + vec2(0.0, px.y)).r;
          float p3 = texture2D(pressure, uv - vec2(0.0, px.y)).r;
          vec2 v = texture2D(velocity, uv).xy;
          vec2 gradP = vec2(p0 - p1, p2 - p3) * 0.5;
          v = v - gradP * dt;
          gl_FragColor = vec4(v, 0.0, 1.0);
        }
      `;

      const viscous_frag = `
        precision highp float;
        uniform sampler2D velocity;
        uniform sampler2D velocity_new;
        uniform float v;
        uniform vec2 px;
        uniform float dt;
        varying vec2 uv;
        void main(){
          vec2 old = texture2D(velocity, uv).xy;
          vec2 new0 = texture2D(velocity_new, uv + vec2(px.x * 2.0, 0.0)).xy;
          vec2 new1 = texture2D(velocity_new, uv - vec2(px.x * 2.0, 0.0)).xy;
          vec2 new2 = texture2D(velocity_new, uv + vec2(0.0, px.y * 2.0)).xy;
          vec2 new3 = texture2D(velocity_new, uv - vec2(0.0, px.y * 2.0)).xy;
          vec2 newv = 4.0 * old + v * dt * (new0 + new1 + new2 + new3);
          newv /= 4.0 * (1.0 + v * dt);
          gl_FragColor = vec4(newv, 0.0, 0.0);
        }
      `;

      // Common state
      const Common = {
        width: window.innerWidth,
        height: window.innerHeight,
        pixelRatio: Math.min(window.devicePixelRatio || 1, 2),
        renderer: null,
        resize() {
          this.width = window.innerWidth;
          this.height = window.innerHeight;
          if (this.renderer) {
            this.renderer.setSize(this.width, this.height, false);
          }
        }
      };

      // Mouse state
      const Mouse = {
        coords: new THREE.Vector2(0, 0),
        coords_old: new THREE.Vector2(0, 0),
        diff: new THREE.Vector2(0, 0),
        isAutoActive: autoDemo,
        update() {
          this.diff.subVectors(this.coords, this.coords_old);
          this.coords_old.copy(this.coords);
          if (this.isAutoActive) {
            this.diff.multiplyScalar(autoIntensity);
          }
        }
      };

      // Auto driver
      let autoPos = new THREE.Vector2(0, 0);
      let autoTarget = new THREE.Vector2();
      let lastAutoTime = performance.now();

      function pickNewAutoTarget() {
        autoTarget.set((Math.random() * 2 - 1) * 0.8, (Math.random() * 2 - 1) * 0.8);
      }
      pickNewAutoTarget();

      function updateAuto() {
        if (!Mouse.isAutoActive) return;
        const now = performance.now();
        const dtAuto = Math.min((now - lastAutoTime) / 1000, 0.016);
        lastAutoTime = now;
        const dir = new THREE.Vector2().subVectors(autoTarget, autoPos);
        const dist = dir.length();
        if (dist < 0.05) {
          pickNewAutoTarget();
          return;
        }
        dir.normalize();
        const move = Math.min(autoSpeed * dtAuto, dist);
        autoPos.addScaledVector(dir, move);
        Mouse.coords.copy(autoPos);
      }

      // Init renderer
      Common.renderer = new THREE.WebGLRenderer({ antialias: false, alpha: true });
      Common.renderer.autoClear = false;
      Common.renderer.setClearColor(0x000000, 0);
      Common.renderer.setPixelRatio(Common.pixelRatio);
      Common.renderer.setSize(Common.width, Common.height);
      container.appendChild(Common.renderer.domElement);

      // Create simulation
      const fboWidth = Math.max(1, Math.round(resolution * Common.width));
      const fboHeight = Math.max(1, Math.round(resolution * Common.height));
      const cellScale = new THREE.Vector2(1.0 / fboWidth, 1.0 / fboHeight);
      const boundarySpace = isBounce ? new THREE.Vector2(0, 0) : cellScale.clone();

      const type = /(iPad|iPhone|iPod)/i.test(navigator.userAgent) ? THREE.HalfFloatType : THREE.FloatType;
      const opts = {
        type,
        depthBuffer: false,
        stencilBuffer: false,
        minFilter: THREE.LinearFilter,
        magFilter: THREE.LinearFilter,
        wrapS: THREE.ClampToEdgeWrapping,
        wrapT: THREE.ClampToEdgeWrapping
      };

      const vel0 = new THREE.WebGLRenderTarget(fboWidth, fboHeight, opts);
      const vel1 = new THREE.WebGLRenderTarget(fboWidth, fboHeight, opts);
      const velViscous0 = new THREE.WebGLRenderTarget(fboWidth, fboHeight, opts);
      const velViscous1 = new THREE.WebGLRenderTarget(fboWidth, fboHeight, opts);
      const div = new THREE.WebGLRenderTarget(fboWidth, fboHeight, opts);
      const pressure0 = new THREE.WebGLRenderTarget(fboWidth, fboHeight, opts);
      const pressure1 = new THREE.WebGLRenderTarget(fboWidth, fboHeight, opts);

      // Advection
      const advectionScene = new THREE.Scene();
      const advectionCamera = new THREE.Camera();
      const advectionMat = new THREE.RawShaderMaterial({
        vertexShader: face_vert,
        fragmentShader: advection_frag,
        uniforms: {
          boundarySpace: { value: cellScale },
          px: { value: cellScale },
          fboSize: { value: new THREE.Vector2(fboWidth, fboHeight) },
          velocity: { value: vel0.texture },
          dt: { value: dt },
          isBFECC: { value: BFECC }
        }
      });
      const advectionMesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), advectionMat);
      advectionScene.add(advectionMesh);

      // External force
      const forceScene = new THREE.Scene();
      const forceCamera = new THREE.Camera();
      const forceMat = new THREE.RawShaderMaterial({
        vertexShader: mouse_vert,
        fragmentShader: externalForce_frag,
        blending: THREE.AdditiveBlending,
        depthWrite: false,
        uniforms: {
          px: { value: cellScale },
          force: { value: new THREE.Vector2(0, 0) },
          center: { value: new THREE.Vector2(0, 0) },
          scale: { value: new THREE.Vector2(cursorSize, cursorSize) }
        }
      });
      const forceMesh = new THREE.Mesh(new THREE.PlaneGeometry(1, 1), forceMat);
      forceScene.add(forceMesh);

      // Divergence
      const divScene = new THREE.Scene();
      const divCamera = new THREE.Camera();
      const divMat = new THREE.RawShaderMaterial({
        vertexShader: face_vert,
        fragmentShader: divergence_frag,
        uniforms: {
          boundarySpace: { value: boundarySpace },
          velocity: { value: vel1.texture },
          px: { value: cellScale },
          dt: { value: dt }
        }
      });
      const divMesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), divMat);
      divScene.add(divMesh);

      // Poisson
      const poissonScene = new THREE.Scene();
      const poissonCamera = new THREE.Camera();
      const poissonMat = new THREE.RawShaderMaterial({
        vertexShader: face_vert,
        fragmentShader: poisson_frag,
        uniforms: {
          boundarySpace: { value: boundarySpace },
          pressure: { value: pressure0.texture },
          divergence: { value: div.texture },
          px: { value: cellScale }
        }
      });
      const poissonMesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), poissonMat);
      poissonScene.add(poissonMesh);

      // Pressure
      const pressureScene = new THREE.Scene();
      const pressureCamera = new THREE.Camera();
      const pressureMat = new THREE.RawShaderMaterial({
        vertexShader: face_vert,
        fragmentShader: pressure_frag,
        uniforms: {
          boundarySpace: { value: boundarySpace },
          pressure: { value: pressure0.texture },
          velocity: { value: vel1.texture },
          px: { value: cellScale },
          dt: { value: dt }
        }
      });
      const pressureMesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), pressureMat);
      pressureScene.add(pressureMesh);

      // Viscous
      const viscousScene = new THREE.Scene();
      const viscousCamera = new THREE.Camera();
      const viscousMat = new THREE.RawShaderMaterial({
        vertexShader: face_vert,
        fragmentShader: viscous_frag,
        uniforms: {
          boundarySpace: { value: boundarySpace },
          velocity: { value: vel1.texture },
          velocity_new: { value: velViscous0.texture },
          v: { value: viscous },
          px: { value: cellScale },
          dt: { value: dt }
        }
      });
      const viscousMesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), viscousMat);
      viscousScene.add(viscousMesh);

      // Output
      const outputScene = new THREE.Scene();
      const outputCamera = new THREE.Camera();
      const outputMat = new THREE.RawShaderMaterial({
        vertexShader: face_vert,
        fragmentShader: color_frag,
        transparent: true,
        uniforms: {
          velocity: { value: vel0.texture },
          boundarySpace: { value: new THREE.Vector2() },
          palette: { value: paletteTex },
          bgColor: { value: bgVec4 }
        }
      });
      const outputMesh = new THREE.Mesh(new THREE.PlaneGeometry(2, 2), outputMat);
      outputScene.add(outputMesh);

      // Mouse events
      container.addEventListener('mousemove', (e) => {
        Mouse.isAutoActive = false;
        const rect = container.getBoundingClientRect();
        Mouse.coords.set(
          ((e.clientX - rect.left) / rect.width) * 2 - 1,
          -((e.clientY - rect.top) / rect.height) * 2 + 1
        );
      });

      container.addEventListener('touchmove', (e) => {
        if (e.touches.length > 0) {
          Mouse.isAutoActive = false;
          const rect = container.getBoundingClientRect();
          Mouse.coords.set(
            ((e.touches[0].clientX - rect.left) / rect.width) * 2 - 1,
            -((e.touches[0].clientY - rect.top) / rect.height) * 2 + 1
          );
        }
      });

      window.addEventListener('resize', () => Common.resize());

      // Animation loop
      function animate() {
        requestAnimationFrame(animate);

        updateAuto();
        Mouse.update();

        // Advection
        Common.renderer.setRenderTarget(vel1);
        Common.renderer.render(advectionScene, advectionCamera);

        // External force
        const forceX = (Mouse.diff.x / 2) * mouseForce;
        const forceY = (Mouse.diff.y / 2) * mouseForce;
        forceMat.uniforms.force.value.set(forceX, forceY);
        forceMat.uniforms.center.value.copy(Mouse.coords);
        Common.renderer.setRenderTarget(vel1);
        Common.renderer.render(forceScene, forceCamera);

        // Viscous (if enabled)
        let velocityOutput = vel1;
        if (isViscous) {
          let v_in, v_out;
          viscousMat.uniforms.velocity.value = vel1.texture;
          for (let i = 0; i < iterationsViscous; i++) {
            v_in = i % 2 === 0 ? velViscous0 : velViscous1;
            v_out = i % 2 === 0 ? velViscous1 : velViscous0;
            viscousMat.uniforms.velocity_new.value = v_in.texture;
            Common.renderer.setRenderTarget(v_out);
            Common.renderer.render(viscousScene, viscousCamera);
          }
          velocityOutput = v_out;
        }

        // Divergence
        divMat.uniforms.velocity.value = velocityOutput.texture;
        Common.renderer.setRenderTarget(div);
        Common.renderer.render(divScene, divCamera);

        // Poisson
        let p_in, p_out;
        for (let i = 0; i < iterationsPoisson; i++) {
          p_in = i % 2 === 0 ? pressure0 : pressure1;
          p_out = i % 2 === 0 ? pressure1 : pressure0;
          poissonMat.uniforms.pressure.value = p_in.texture;
          Common.renderer.setRenderTarget(p_out);
          Common.renderer.render(poissonScene, poissonCamera);
        }

        // Pressure
        pressureMat.uniforms.velocity.value = velocityOutput.texture;
        pressureMat.uniforms.pressure.value = p_out.texture;
        Common.renderer.setRenderTarget(vel0);
        Common.renderer.render(pressureScene, pressureCamera);

        // Output
        Common.renderer.setRenderTarget(null);
        Common.renderer.render(outputScene, outputCamera);
      }

      animate();
    })();
  </script>
</body>
</html>
