name: Deploy
run-name: Deploy to ${{ github.event_name == 'push' && 'staging' || github.event.inputs.environment || 'staging' }}

on:
  workflow_dispatch:
    inputs:
      environment:
        type: choice
        required: true
        default: staging
        description: 'Deployment environment'
        options:
          - staging
          - production

  # Automatic staging deployment on push to main
  push:
    branches:
      - main

permissions:
  contents: write
  id-token: write

env:
  GCP_REGION: us-east4
  
  # Workload Identity Providers (environment-specific)
  STAGING_WORKLOAD_IDENTITY_PROVIDER: projects/391319920980/locations/global/workloadIdentityPools/github-pool/providers/github-provider
  PROD_WORKLOAD_IDENTITY_PROVIDER: projects/480289563704/locations/global/workloadIdentityPools/github-pool/providers/github-provider
  
  # Service Accounts (environment-specific)
  STAGING_SERVICE_ACCOUNT: github-ci@verc-staging.iam.gserviceaccount.com
  PROD_SERVICE_ACCOUNT: github-ci@verc-prod.iam.gserviceaccount.com

  # Cloud Run services
  STAGING_PROJECT: verc-staging
  PROD_PROJECT: verc-prod
  STAGING_SERVICE: verc-app-staging
  PROD_SERVICE: verc-app-prod

  # Artifact Registry Repos
  STAGING_REPO: verc-app-staging
  PROD_REPO: verc-app-prod

jobs:
  setup-build-publish:
    runs-on: ubuntu-latest

    # Determine environment:
    # push → staging
    # manual → github.event.inputs.environment
    environment: ${{ github.event_name == 'push' && 'staging' || github.event.inputs.environment || 'staging' }}

    outputs:
      image_path: ${{ steps.build-image.outputs.image_path }}
      deploy_env: ${{ steps.env-select.outputs.deploy_env }}
      service_name: ${{ steps.env-select.outputs.service_name }}
      project_id: ${{ steps.env-select.outputs.project_id }}
      repository: ${{ steps.env-select.outputs.repository }}
      service_account: ${{ steps.env-select.outputs.service_account }}
      workload_identity_provider: ${{ steps.env-select.outputs.workload_identity_provider }}

    steps:
      - uses: actions/checkout@v4
        with:
          fetch-depth: 0
          fetch-tags: true

      ###############################################################
      # 0. SELECT ENVIRONMENT + SERVICES + REPOS
      ###############################################################
      - name: Select Environment
        id: env-select
        run: |
          if [ "${{ github.event_name }}" = "push" ]; then
            echo "deploy_env=staging" >> $GITHUB_OUTPUT
            echo "service_name=${{ env.STAGING_SERVICE }}" >> $GITHUB_OUTPUT
            echo "project_id=${{ env.STAGING_PROJECT }}" >> $GITHUB_OUTPUT
            echo "repository=${{ env.STAGING_REPO }}" >> $GITHUB_OUTPUT
            echo "service_account=${{ env.STAGING_SERVICE_ACCOUNT }}" >> $GITHUB_OUTPUT
            echo "workload_identity_provider=${{ env.STAGING_WORKLOAD_IDENTITY_PROVIDER }}" >> $GITHUB_OUTPUT
          else
            ENV_INPUT="${{ github.event.inputs.environment }}"
            if [ "$ENV_INPUT" = "production" ]; then
              echo "deploy_env=production" >> $GITHUB_OUTPUT
              echo "service_name=${{ env.PROD_SERVICE }}" >> $GITHUB_OUTPUT
              echo "project_id=${{ env.PROD_PROJECT }}" >> $GITHUB_OUTPUT
              echo "repository=${{ env.PROD_REPO }}" >> $GITHUB_OUTPUT
              echo "service_account=${{ env.PROD_SERVICE_ACCOUNT }}" >> $GITHUB_OUTPUT
              echo "workload_identity_provider=${{ env.PROD_WORKLOAD_IDENTITY_PROVIDER }}" >> $GITHUB_OUTPUT
            else
              echo "deploy_env=staging" >> $GITHUB_OUTPUT
              echo "service_name=${{ env.STAGING_SERVICE }}" >> $GITHUB_OUTPUT
              echo "project_id=${{ env.STAGING_PROJECT }}" >> $GITHUB_OUTPUT
              echo "repository=${{ env.STAGING_REPO }}" >> $GITHUB_OUTPUT
              echo "service_account=${{ env.STAGING_SERVICE_ACCOUNT }}" >> $GITHUB_OUTPUT
              echo "workload_identity_provider=${{ env.STAGING_WORKLOAD_IDENTITY_PROVIDER }}" >> $GITHUB_OUTPUT
            fi
          fi

      ###############################################################
      # 1. AUTHENTICATE TO GOOGLE CLOUD
      ###############################################################
      - uses: google-github-actions/auth@v2
        id: auth
        with:
          workload_identity_provider: ${{ steps.env-select.outputs.workload_identity_provider }}
          service_account: ${{ steps.env-select.outputs.service_account }}

      - uses: google-github-actions/setup-gcloud@v2

      - name: Configure Artifact Registry
        run: |
          gcloud auth configure-docker ${{ env.GCP_REGION }}-docker.pkg.dev --quiet

      ###############################################################
      # 2. BUILD + PUSH DOCKER IMAGE
      ###############################################################
      - name: Build Docker Image
        id: build-image
        run: |
          IMAGE_PATH="${{ env.GCP_REGION }}-docker.pkg.dev/${{ steps.env-select.outputs.project_id }}/${{ steps.env-select.outputs.repository }}/django-backend:${{ github.sha }}"
          echo "Building image: $IMAGE_PATH"

          docker build --platform linux/amd64 -t $IMAGE_PATH .
          docker push $IMAGE_PATH

          echo "image_path=$IMAGE_PATH" >> $GITHUB_OUTPUT

  ###################################################################
  # 3. DEPLOY TO CLOUD RUN
  ###################################################################
  deploy:
    needs: setup-build-publish
    runs-on: ubuntu-latest
    environment: ${{ needs.setup-build-publish.outputs.deploy_env }}

    steps:
      - uses: google-github-actions/auth@v2
        with:
          workload_identity_provider: ${{ needs.setup-build-publish.outputs.workload_identity_provider }}
          service_account: ${{ needs.setup-build-publish.outputs.service_account }}

      - uses: google-github-actions/setup-gcloud@v2

      - name: Deploy to Cloud Run
        id: deploy-backend
        run: |
          SERVICE="${{ needs.setup-build-publish.outputs.service_name }}"
          PROJECT="${{ needs.setup-build-publish.outputs.project_id }}"
          ENV="${{ needs.setup-build-publish.outputs.deploy_env }}"

          # Set gcloud project
          gcloud config set project "$PROJECT"

          # Previous URL (if exists)
          SERVICE_URL=$(gcloud run services describe "$SERVICE" \
            --region ${{ env.GCP_REGION }} \
            --project "$PROJECT" \
            --format 'value(status.url)' 2>/dev/null || echo "")

          echo "Deploying to service: $SERVICE in project: $PROJECT (environment: $ENV)"

          # Determine task queue name based on environment
          if [ "$ENV" = "production" ]; then
            TASK_QUEUE="transcription-queue-prod-v2"
            # Get production project number for compute service account
            PROJECT_NUMBER=$(gcloud projects describe "$PROJECT" --format='value(projectNumber)')
            RUN_SERVICE_ACCOUNT="${PROJECT_NUMBER}-compute@developer.gserviceaccount.com"
          else
            TASK_QUEUE="transcription-queue-staging-v2"
            # Staging uses project 391319920980
            RUN_SERVICE_ACCOUNT="391319920980-compute@developer.gserviceaccount.com"
          fi

          echo "Using Cloud Run service account: $RUN_SERVICE_ACCOUNT"

          gcloud run deploy "$SERVICE" \
            --image "${{ needs.setup-build-publish.outputs.image_path }}" \
            --region "${{ env.GCP_REGION }}" \
            --project "$PROJECT" \
            --platform managed \
            --allow-unauthenticated \
            --service-account "$RUN_SERVICE_ACCOUNT" \
            --memory 512Mi \
            --cpu 1 \
            --min-instances 0 \
            --max-instances 5 \
            --concurrency 80 \
            --timeout 300 \
            --set-env-vars "NODE_ENV=production,ENVIRONMENT=$ENV,GCP_PROJECT_ID=$PROJECT,GCP_REGION=${{ env.GCP_REGION }},GCP_TASK_QUEUE_NAME=$TASK_QUEUE,CLOUD_TASKS_ENABLED=true,CLOUD_TASKS_SERVICE_ACCOUNT_EMAIL=cloud-tasks-invoker@$PROJECT.iam.gserviceaccount.com,ASSEMBLYAI_PII_REDACTION_ENABLED=true,ASSEMBLYAI_PII_SUBSTITUTION=entity_name,ASSEMBLYAI_GENERATE_REDACTED_AUDIO=true,DJANGO_ENV=production,CLOUD_RUN_SERVICE_URL=$SERVICE_URL,DB_NAME=verc_app,DB_USER=verc_app_user,DB_PORT=5432" \
            --set-secrets "SUPABASE_URL=supabase-url:latest,SUPABASE_ANON_KEY=supabase-anon-key:latest,SUPABASE_SERVICE_ROLE_KEY=supabase-service-role-key:latest,OPENAI_API_KEY=openai-api-key:latest,ANTHROPIC_API_KEY=anthropic-api-key:latest,ASSEMBLYAI_API_KEY=assemblyai-api-key:latest,TWILIO_ACCOUNT_SID=twilio-account-sid:latest,TWILIO_AUTH_TOKEN=twilio-auth-token:latest,TWILIO_PHONE_NUMBER=twilio-phone-number:latest,TWILIO_WEBHOOK_BASE_URL=TWILIO_WEBHOOK_BASE_URL:latest,DB_PASSWORD=db-password:latest,DB_HOST=db-host:latest"

          # Wait a bit for deployment to complete
          echo "Waiting for deployment to stabilize..."
          sleep 5

          # Get updated URL
          URL=$(gcloud run services describe "$SERVICE" \
            --region ${{ env.GCP_REGION }} \
            --project "$PROJECT" \
            --format 'value(status.url)')

          if [ -z "$URL" ]; then
            echo "❌ Failed to get service URL"
            exit 1
          fi

          echo "Backend deployed to: $URL"
          echo "url=$URL" >> $GITHUB_OUTPUT

      ###################################################################
      # 4. HEALTH CHECK
      ###################################################################
      - name: Health Check
        run: |
          URL="${{ steps.deploy-backend.outputs.url }}"
          HEALTH_URL="${URL}/health"
          
          echo "Waiting 10 seconds for service to be ready..."
          sleep 10
          
          echo "Checking health at $HEALTH_URL"
          
          # Retry logic: try up to 5 times with exponential backoff
          MAX_RETRIES=5
          RETRY_COUNT=0
          SUCCESS=false
          
          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            echo "Attempt $((RETRY_COUNT + 1))/$MAX_RETRIES..."
            
            # Try the health check
            HTTP_CODE=$(curl -s -o /tmp/health_response.txt -w "%{http_code}" "$HEALTH_URL" || echo "000")
            
            if [ "$HTTP_CODE" = "200" ]; then
              echo "✅ Health check passed (HTTP $HTTP_CODE)"
              cat /tmp/health_response.txt
              SUCCESS=true
              break
            else
              echo "⚠️  Health check returned HTTP $HTTP_CODE"
              if [ -f /tmp/health_response.txt ]; then
                echo "Response:"
                cat /tmp/health_response.txt
              fi
              
              if [ $RETRY_COUNT -lt $((MAX_RETRIES - 1)) ]; then
                WAIT_TIME=$((2 ** RETRY_COUNT))
                echo "Waiting ${WAIT_TIME} seconds before retry..."
                sleep $WAIT_TIME
              fi
            fi
            
            RETRY_COUNT=$((RETRY_COUNT + 1))
          done
          
          if [ "$SUCCESS" = "false" ]; then
            echo "❌ Health check FAILED after $MAX_RETRIES attempts"
            echo "Service URL: $URL"
            echo "Health URL: $HEALTH_URL"
            exit 1
          fi

      ###################################################################
      # 5. SUMMARY
      ###################################################################
      - name: Summary
        run: |
          echo "=================================================="
          echo "Deployment Complete"
          echo "Environment:  ${{ needs.setup-build-publish.outputs.deploy_env }}"
          echo "Service:      ${{ needs.setup-build-publish.outputs.service_name }}"
          echo "Backend URL:  ${{ steps.deploy-backend.outputs.url }}"
          echo "=================================================="
